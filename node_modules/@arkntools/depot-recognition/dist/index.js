"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  DeportRecognizer: true
};
exports.DeportRecognizer = void 0;
var _castArray = _interopRequireDefault(require("lodash/castArray.js"));
var _intersection = _interopRequireDefault(require("lodash/intersection.js"));
var _merge = _interopRequireDefault(require("lodash/merge.js"));
var _jszip = _interopRequireDefault(require("jszip"));
var _jimp = _interopRequireDefault(require("jimp"));
var _flatMap = _interopRequireDefault(require("lodash/flatMap.js"));
var _flatten = _interopRequireDefault(require("lodash/flatten.js"));
var _map = _interopRequireDefault(require("lodash/map.js"));
var _maxBy = _interopRequireDefault(require("lodash/maxBy.js"));
var _min = _interopRequireDefault(require("lodash/min.js"));
var _range = _interopRequireDefault(require("lodash/range.js"));
var _uniqBy = _interopRequireDefault(require("lodash/uniqBy.js"));
var _simpleStatistics = require("simple-statistics");
var _findIndex = _interopRequireDefault(require("lodash/findIndex.js"));
var _last = _interopRequireDefault(require("lodash/last.js"));
var _remove = _interopRequireDefault(require("lodash/remove.js"));
var _transform = _interopRequireDefault(require("lodash/transform.js"));
var _sum = _interopRequireDefault(require("lodash/sum.js"));
var _ocrad = _interopRequireDefault(require("@arkntools/scripts/dist/ocrad"));
var _findLast = _interopRequireDefault(require("lodash/findLast.js"));
var _sortBy = _interopRequireDefault(require("lodash/sortBy.js"));
var _tools = require("./tools");
Object.keys(_tools).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _tools[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tools[key];
    }
  });
});
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const jimp2base64 = img => {
  return img.getBase64Async(_jimp.default.MIME_PNG);
};
const GAUSS_CORE = [[2 / 159, 4 / 159, 5 / 159, 4 / 159, 2 / 159], [4 / 159, 9 / 159, 12 / 159, 9 / 159, 4 / 159], [5 / 159, 12 / 159, 15 / 159, 12 / 159, 5 / 159], [4 / 159, 9 / 159, 12 / 159, 9 / 159, 4 / 159], [2 / 159, 4 / 159, 5 / 159, 4 / 159, 2 / 159]];
const jimpGaussBlur = img => img.convolution(GAUSS_CORE);
const getRangeEnd = ({
  start,
  length
}) => start + length;
const inRange = (x, {
  start,
  length
}) => start <= x && x < start + length;
const findRangeIndex = (x, ranges) => (0, _findIndex.default)(ranges, range => inRange(x, range));
const getRanges = arr => (0, _transform.default)(arr, (a, inRange, x) => {
  if (!a.length) {
    if (inRange) a.push({
      start: x,
      length: 1
    });
    return;
  }
  if (inRange) {
    const lastRange = (0, _last.default)(a);
    if (x === getRangeEnd(lastRange)) lastRange.length++;else a.push({
      start: x,
      length: 1
    });
  }
}, []);
const getRangesBy = (arr, fn, preCalc) => {
  const ranges = getRanges(arr);
  const data = preCalc === null || preCalc === void 0 ? void 0 : preCalc(ranges);
  return ranges.filter(range => fn(range, data));
};
const removeRangesNoise = (ranges, size = 1) => (0, _remove.default)(ranges, ({
  length
}) => length <= size);
const ORIG_MAX_WIDTH = 960;
const ORIG_MAX_HEIGHT = 540;
const ITEM_VIEW_SCALE = 1.15;
const ITEM_DEBUG_VIEW_W = 60;
const ITEM_X_SPACE_RATIO = 29 / 88;
const EDGE_CORE = [[1, 1, 1], [1, -9, 1], [1, 1, 1]];
const itemDetection = (origImg, isDebug = false) => {
  const img = origImg.clone();
  const scale = (() => {
    const w = img.getWidth();
    const h = img.getHeight();
    if (w >= h && w > ORIG_MAX_WIDTH) img.resize(ORIG_MAX_WIDTH, _jimp.default.AUTO);else if (h > w && h > ORIG_MAX_HEIGHT) img.resize(_jimp.default.AUTO, ORIG_MAX_HEIGHT);else return 1;
    return w / img.getWidth();
  })();
  const edgeImg = img.clone().greyscale().convolution(EDGE_CORE);
  const width = edgeImg.getWidth();
  const height = edgeImg.getHeight();
  const yWhite = new Array(height).fill(0);
  const removedEdgeWith = Math.round(width * 0.15);
  edgeImg.scan(removedEdgeWith, 0, width - removedEdgeWith, height, function (x, y, idx) {
    yWhite[y] += this.bitmap.data[idx];
  });
  const yRangeMinLine = width * 0.005 * 255;
  const yRanges = getRangesBy(yWhite.map(v => v > yRangeMinLine), ({
    length
  }, minLen) => length > minLen, ranges => (0, _maxBy.default)(ranges, 'length').length * 0.8);
  let itemWidth = (0, _min.default)((0, _map.default)(yRanges, 'length'));
  const xWhites = yRanges.map(() => new Array(width).fill(0));
  edgeImg.scan(0, 0, width, height, function (x, y, idx) {
    const yRangeIndex = findRangeIndex(y, yRanges);
    if (yRangeIndex !== -1) xWhites[yRangeIndex][x] += this.bitmap.data[idx];
  });
  const xsRanges = xWhites.map(xWhite => getRangesBy(xWhite.map(v => v > 0), ({
    start,
    length
  }) => start > 0 && start + length < width && itemWidth * 0.9 < length && length < itemWidth * 1.2));
  const xRangeMinLength = 0.05 * itemWidth;
  const xItemWidths = (0, _map.default)((0, _flatten.default)(xsRanges).filter(({
    start,
    length
  }) => start !== 0 && start + length !== width && length < itemWidth && length > xRangeMinLength), 'length');
  if (xItemWidths.length) {
    itemWidth = (0, _min.default)(xItemWidths);
  }
  const itemsRange = (0, _flatten.default)(xsRanges.map((xRanges, y) => {
    const yRange = yRanges[y];
    return xRanges.map(xRange => {
      const yWhite = new Array(yRange.length).fill(0);
      edgeImg.scan(xRange.start, yRange.start, xRange.length, yRange.length, function (x, y, idx) {
        yWhite[y - yRange.start] += this.bitmap.data[idx];
      });
      const yRangeMinLine = xRange.length * 0.005 * 255;
      const [resultYRange] = getRangesBy(yWhite.map(v => v > yRangeMinLine), range => itemWidth * 0.9 < range.length && range.length < itemWidth * 1.2);
      if (!resultYRange) return null;
      resultYRange.start += yRange.start;
      return {
        y,
        xRange,
        yRange: resultYRange
      };
    }).filter(v => !!v);
  }));
  itemWidth = (0, _min.default)((0, _flatMap.default)(itemsRange, ({
    xRange,
    yRange
  }) => [xRange.length, yRange.length])) || itemWidth;
  const xOccu = itemWidth * (1 + ITEM_X_SPACE_RATIO);
  const xCents = itemsRange.map(({
    xRange: {
      start,
      length
    }
  }) => start + length / 2);
  const firstXCent = (0, _min.default)(xCents);
  const firstColOffset = Math.ceil(firstXCent / xOccu);
  const xPoints = xCents.map(y => [firstColOffset + Math.round((y - firstXCent) / xOccu), y]);
  const yPoints = itemsRange.map(({
    y,
    yRange: {
      start,
      length
    }
  }) => [y, start + length / 2]);
  const getMidX = (0, _simpleStatistics.linearRegressionLine)((0, _simpleStatistics.linearRegression)(xPoints));
  const getMidY = (0, _simpleStatistics.linearRegressionLine)((0, _simpleStatistics.linearRegression)(yPoints));
  const trueItemWidth = Math.round(itemWidth * scale);
  const colNum = Math.floor((width + itemWidth * (1 + ITEM_X_SPACE_RATIO)) / xOccu);
  const rowNum = yRanges.length;
  const xPoss = (0, _range.default)(colNum).map(col => {
    const offset = (col + 1) / colNum * -1;
    const midX = getMidX(col) + offset;
    const x = Math.round((midX - itemWidth / 2) * scale);
    const left = (midX - itemWidth * ITEM_VIEW_SCALE / 2) / width;
    const right = 1 - (midX + itemWidth * ITEM_VIEW_SCALE / 2) / width;
    return {
      pos: {
        x,
        col
      },
      view: {
        left,
        right
      }
    };
  }).filter(({
    pos: {
      x
    }
  }) => x >= 0 && x + trueItemWidth <= origImg.getWidth());
  const yPoss = (0, _range.default)(rowNum).map(row => {
    const midY = getMidY(row);
    const y = Math.round((midY - itemWidth / 2) * scale);
    const top = (midY - itemWidth * ITEM_VIEW_SCALE / 2) / height;
    const bottom = 1 - (midY + itemWidth * ITEM_VIEW_SCALE / 2) / height;
    return {
      pos: {
        y,
        l: trueItemWidth,
        row
      },
      view: {
        top,
        bottom
      }
    };
  });
  const positions = (0, _flatMap.default)((0, _uniqBy.default)((0, _flatten.default)(xPoss), 'pos.x'), xPos => (0, _uniqBy.default)((0, _flatten.default)(yPoss), 'pos.y').map(yPos => (0, _merge.default)({
    debug: {
      scale: ITEM_DEBUG_VIEW_W / (scale * itemWidth)
    }
  }, xPos, yPos)));
  const debugImgs = [];
  if (isDebug) {
    const debugSquareImg = origImg.clone();
    positions.forEach(({
      pos: {
        x,
        y
      }
    }) => {
      for (let ix = x; ix < x + trueItemWidth; ix++) {
        debugSquareImg.setPixelColor(0xff0000ff, ix, y);
        debugSquareImg.setPixelColor(0xff0000ff, ix, y + trueItemWidth - 1);
      }
      for (let iy = y; iy < y + trueItemWidth; iy++) {
        debugSquareImg.setPixelColor(0xff0000ff, x, iy);
        debugSquareImg.setPixelColor(0xff0000ff, x + trueItemWidth - 1, iy);
      }
    });
    debugImgs.push(debugSquareImg);
    const debugRowImg = edgeImg.clone();
    yRanges.forEach(({
      start,
      length
    }) => {
      debugRowImg.scan(0, start, width, length, function (x, y, idx) {
        debugRowImg.bitmap.data[idx] = 200;
      });
    });
    debugImgs.push(debugRowImg);
    const debugItemImg = edgeImg.clone();
    itemsRange.forEach(({
      xRange,
      yRange
    }) => {
      debugRowImg.scan(xRange.start, yRange.start, xRange.length, yRange.length, function (x, y, idx) {
        debugItemImg.bitmap.data[idx] = 200;
      });
    });
    debugImgs.push(debugItemImg);
  }
  return {
    debugImgs,
    positions,
    itemWidth: Math.round(itemWidth * scale)
  };
};
class ImageDataPolyfill {
  constructor(data, width, height) {
    this.data = data;
    this.width = width;
    this.height = height;
  }
}
var ImageData$1 = typeof ImageData === 'undefined' ? ImageDataPolyfill : ImageData;
const NUM_RESIZE_H = 60;
const NUM_MIN_WIDTH = 8;
const NUM_MAX_SPACE = 20;
const NUM_IMG_PADDING = 10;
const NUM_APPEND_SPACE = 8;
const NUM_CROP_W = 50;
const NUM_CROP_H = 22;
const NUM_CROP_X = 40;
const NUM_CROP_Y = 73;
const NUM_CONVOLUTION_CORE = (size => (line => new Array(size).fill(line))(new Array(size).fill(1 / (size * size))))(3);
const getBlackColRanges = (img, fn) => {
  const w = img.getWidth();
  const blackArr = [];
  for (let x = 0; x < w; x++) {
    blackArr.push(fn(img, x));
  }
  return getRanges(blackArr);
};
const isColHasBlack = (img, x) => {
  const h = img.getHeight();
  for (let y = 0; y < h; y++) {
    const {
      r
    } = _jimp.default.intToRGBA(img.getPixelColor(x, y));
    if (r < 128) return true;
  }
  return false;
};
const splitNumbers = ({
  splittedImgs,
  itemWidth,
  simResults,
  IMG_SL
}) => {
  const numRatio = itemWidth / IMG_SL;
  const numX = Math.round(NUM_CROP_X * numRatio);
  const numY = Math.round(NUM_CROP_Y * numRatio);
  const numW = Math.round(NUM_CROP_W * numRatio);
  const numH = Math.round(NUM_CROP_H * numRatio);
  return splittedImgs.map((splittedImg, i) => {
    var _a;
    if (!simResults[i]) return null;
    const numImg = splittedImg.clone().crop(numX, numY, numW, numH).resize(_jimp.default.AUTO, NUM_RESIZE_H, _jimp.default.RESIZE_BEZIER).invert().threshold({
      max: 104
    });
    const numImgH = numImg.getHeight();
    const numImgBlackRanges = getBlackColRanges(numImg, isColHasBlack);
    removeRangesNoise(numImgBlackRanges, NUM_MIN_WIDTH);
    if (((_a = numImgBlackRanges[0]) === null || _a === void 0 ? void 0 : _a.start) === 0) numImgBlackRanges.splice(0, 1);
    (0, _remove.default)(numImgBlackRanges, ({
      start,
      length
    }, j) => {
      const next = numImgBlackRanges[j + 1];
      if (next && next.start - (start + length) > NUM_MAX_SPACE) return true;
      const yBlack = new Array(numImgH).fill(0);
      numImg.scan(start, 0, length, numImgH, function (x, y, idx) {
        yBlack[y] += 255 - this.bitmap.data[idx];
      });
      const yRanges = getRanges(yBlack.map(v => v > 0));
      if (yBlack[0] || (0, _last.default)(yBlack)) return true;
      if ((0, _sum.default)((0, _map.default)(yRanges, 'length')) < numImgH * 0.5) return true;
      return false;
    });
    if (!numImgBlackRanges.length) {
      numImgBlackRanges.push({
        start: 0,
        length: numImg.getWidth()
      });
    }
    const newNumImg = new _jimp.default(NUM_IMG_PADDING * 2 + (0, _sum.default)((0, _map.default)(numImgBlackRanges, 'length')) + (numImgBlackRanges.length - 1) * NUM_APPEND_SPACE, numImgH, 'white');
    let curX = NUM_IMG_PADDING;
    for (const {
      start,
      length
    } of numImgBlackRanges) {
      if (curX !== NUM_IMG_PADDING) curX += NUM_APPEND_SPACE;
      newNumImg.blit(numImg, curX, 0, start, 0, length, numImgH);
      curX += length;
    }
    newNumImg.convolution(NUM_CONVOLUTION_CORE).invert().threshold({
      max: 16,
      autoGreyscale: false
    }).invert();
    return newNumImg;
  });
};
const recognizeNumbers = numImgs => Promise.all(numImgs.map(async img => {
  if (!img) return null;
  const imgData = new ImageData$1(new Uint8ClampedArray(img.bitmap.data), img.bitmap.width, img.bitmap.height);
  const text = (0, _ocrad.default)(imgData, {
    numeric: true
  }).trim();
  const value = parseInt(text.replace(/[^0-9]/g, '')) || 1;
  return {
    img: await jimp2base64(img),
    text,
    value,
    warn: text.replace(/ /g, '') !== String(value)
  };
}));
const MAX_TRUST_DIFF = {
  DEFAULT: 0.2,
  30021: 0.15,
  30041: 0.12,
  30042: 0.12,
  30043: 0.12,
  30044: 0.12,
  30062: 0.15,
  31024: 0.22
};
const MAX_CLOSE_DIFF = 0.005;
const isDiffsTooClose = diffs => diffs.length >= 2 && Math.abs(diffs[0][1] - diffs[1][1]) < MAX_CLOSE_DIFF;
const isTrustedSimResult = sim => {
  var _a;
  if (!sim) return false;
  const {
    diff,
    name
  } = sim;
  const maxTrustDiff = (_a = MAX_TRUST_DIFF[name]) !== null && _a !== void 0 ? _a : MAX_TRUST_DIFF.DEFAULT;
  return diff < maxTrustDiff;
};
const getSim = (input, imgMap, order) => {
  if (!order.length) return null;
  const diffs = (0, _sortBy.default)(order.map(id => [id, _jimp.default.diff(input, imgMap.get(id), 0.2).percent]), 1);
  const [name, diff] = diffs[0];
  return {
    name,
    diff,
    diffs,
    diffsTooClose: isDiffsTooClose(diffs)
  };
};
const getSims = (inputs, imgMap, order) => {
  if (inputs.length <= 2) {
    return inputs.map(input => getSim(input, imgMap, order));
  }
  const inputCenterI = Math.floor(inputs.length / 2);
  const inputCenterSim = getSim(inputs[inputCenterI], imgMap, order);
  if (isTrustedSimResult(inputCenterSim) && !inputCenterSim.diffsTooClose) {
    const compareCenterI = order.findIndex(name => name === inputCenterSim.name);
    return [...getSims(inputs.slice(0, inputCenterI), imgMap, order.slice(0, compareCenterI)), inputCenterSim, ...getSims(inputs.slice(inputCenterI + 1), imgMap, order.slice(compareCenterI + 1))];
  } else {
    const leftSims = getSims(inputs.slice(0, inputCenterI), imgMap, order);
    const leftLastSim = (0, _findLast.default)(leftSims, sim => sim);
    const rightSims = getSims(inputs.slice(inputCenterI + 1), imgMap, isTrustedSimResult(leftLastSim) ? order.slice(order.findIndex(name => name === leftLastSim.name) + 1) : order);
    return [...leftSims, inputCenterSim, ...rightSims];
  }
};
const IMG_SL = 100;
const IMG_ORIG_SL = 183;
const IMG_CROP_SL = 151;
const IMG_CROP_XY = (IMG_ORIG_SL - IMG_CROP_SL) / 2;
const NUM_MASK_IMG = new _jimp.default(54, 28, 'white');
const NUM_MASK_X = 39;
const NUM_MASK_Y = 70;
class DeportRecognizer {
  constructor(config) {
    this.config = Object.assign({}, config);
    this.isDebug = false;
    if (config.preload) this.preloadResource();
  }
  setDebug(enable) {
    this.isDebug = enable;
  }
  setOrder(order) {
    this.config.order = order;
    this.itemOrder = undefined;
  }
  preloadResource() {
    if (this.preloadResourcePromise) return;
    this.preloadResourcePromise = (async () => {
      try {
        await this.loadResource();
      } catch (error) {
        console.error(error);
      } finally {
        this.preloadResourcePromise = undefined;
      }
    })();
  }
  async loadResource() {
    if (!this.itemImgMap) {
      const zip = await _jszip.default.loadAsync(...(0, _castArray.default)(this.config.pkg));
      this.itemImgMap = new Map((await Promise.all(zip.filter(path => path.endsWith('.png')).map(async file => {
        try {
          const img = await _jimp.default.read(await file.async('arraybuffer'));
          return [file.name.replace(/\.png$/, ''), jimpGaussBlur(img.crop(IMG_CROP_XY, IMG_CROP_XY, IMG_CROP_SL, IMG_CROP_SL)).resize(IMG_SL, IMG_SL, _jimp.default.RESIZE_BEZIER).composite(NUM_MASK_IMG, NUM_MASK_X, NUM_MASK_Y).circle()];
        } catch (e) {
          console.error('[depot-recognition]', e);
        }
      }))).filter(data => data === null || data === void 0 ? void 0 : data[1]));
    }
    if (!this.itemOrder) {
      this.itemOrder = (0, _intersection.default)(this.config.order, Array.from(this.itemImgMap.keys()));
    }
    return {
      imgMap: this.itemImgMap,
      order: this.itemOrder
    };
  }
  async recognize(file, onProgress = () => {}) {
    const debugImgs = [];
    const nextProgress = (() => {
      let progress = 0;
      return () => onProgress(progress++);
    })();
    nextProgress();
    if (this.preloadResourcePromise) await this.preloadResourcePromise;
    const [origImg, itemData] = await Promise.all([_jimp.default.read(file), this.loadResource()]);
    if (this.isDebug) debugImgs.push(...itemData.imgMap.values());
    nextProgress();
    const {
      positions,
      itemWidth,
      debugImgs: itemDetectionDebugImgs
    } = itemDetection(origImg, this.isDebug);
    const splittedImgs = positions.map(({
      pos: {
        x,
        y
      }
    }) => origImg.clone().crop(x, y, itemWidth, itemWidth));
    const compareImgs = splittedImgs.map(img => img.clone().resize(IMG_SL, IMG_SL).composite(NUM_MASK_IMG, NUM_MASK_X, NUM_MASK_Y).circle());
    if (this.isDebug) {
      debugImgs.push(...compareImgs);
      debugImgs.push(...itemDetectionDebugImgs);
    }
    nextProgress();
    const simResults = getSims(compareImgs, itemData.imgMap, itemData.order);
    nextProgress();
    const numImgs = splitNumbers({
      splittedImgs,
      itemWidth,
      simResults,
      IMG_SL
    });
    nextProgress();
    const numResults = await recognizeNumbers(numImgs);
    return {
      data: (0, _merge.default)(positions, simResults.map(sim => ({
        sim
      })), numResults.map(num => ({
        num
      }))),
      debug: await Promise.all(debugImgs.map(jimp2base64))
    };
  }
}
exports.DeportRecognizer = DeportRecognizer;
