import { castArray, intersection, merge } from 'lodash';
import JSZip from 'jszip';
import Jimp from 'jimp';
import { jimp2base64, jimpGaussBlur } from '../utils/jimpUtils';
import { itemDetection } from './itemDetection';
import { splitNumbers, recognizeNumbers } from './number';
import { getSims } from './similarity';
const IMG_SL = 100;
const IMG_ORIG_SL = 183;
const IMG_CROP_SL = 151;
const IMG_CROP_XY = (IMG_ORIG_SL - IMG_CROP_SL) / 2;
const NUM_MASK_IMG = new Jimp(54, 28, 'white');
const NUM_MASK_X = 39;
const NUM_MASK_Y = 70;
export class DeportRecognizer {
    constructor(config) {
        this.config = Object.assign({}, config);
        this.isDebug = false;
        if (config.preload)
            this.preloadResource();
    }
    setDebug(enable) {
        this.isDebug = enable;
    }
    setOrder(order) {
        this.config.order = order;
        this.itemOrder = undefined;
    }
    preloadResource() {
        if (this.preloadResourcePromise)
            return;
        this.preloadResourcePromise = (async () => {
            try {
                await this.loadResource();
            }
            catch (error) {
                console.error(error);
            }
            finally {
                this.preloadResourcePromise = undefined;
            }
        })();
    }
    async loadResource() {
        if (!this.itemImgMap) {
            const zip = await JSZip.loadAsync(...castArray(this.config.pkg));
            this.itemImgMap = new Map((await Promise.all(zip
                .filter(path => path.endsWith('.png'))
                .map(async (file) => {
                try {
                    const img = await Jimp.read((await file.async('arraybuffer')));
                    return [
                        file.name.replace(/\.png$/, ''),
                        jimpGaussBlur(img.crop(IMG_CROP_XY, IMG_CROP_XY, IMG_CROP_SL, IMG_CROP_SL))
                            .resize(IMG_SL, IMG_SL, Jimp.RESIZE_BEZIER)
                            .composite(NUM_MASK_IMG, NUM_MASK_X, NUM_MASK_Y)
                            .circle(),
                    ];
                }
                catch (e) {
                    console.error('[depot-recognition]', e);
                }
            }))).filter(data => data === null || data === void 0 ? void 0 : data[1]));
        }
        if (!this.itemOrder) {
            this.itemOrder = intersection(this.config.order, Array.from(this.itemImgMap.keys()));
        }
        return {
            imgMap: this.itemImgMap,
            order: this.itemOrder,
        };
    }
    async recognize(file, onProgress = () => { }) {
        const debugImgs = [];
        const nextProgress = (() => {
            let progress = 0;
            return () => onProgress(progress++);
        })();
        nextProgress();
        if (this.preloadResourcePromise)
            await this.preloadResourcePromise;
        const [origImg, itemData] = await Promise.all([Jimp.read(file), this.loadResource()]);
        if (this.isDebug)
            debugImgs.push(...itemData.imgMap.values());
        nextProgress();
        const { positions, itemWidth, debugImgs: itemDetectionDebugImgs, } = itemDetection(origImg, this.isDebug);
        const splittedImgs = positions.map(({ pos: { x, y } }) => origImg.clone().crop(x, y, itemWidth, itemWidth));
        const compareImgs = splittedImgs.map(img => img.clone().resize(IMG_SL, IMG_SL).composite(NUM_MASK_IMG, NUM_MASK_X, NUM_MASK_Y).circle());
        if (this.isDebug) {
            debugImgs.push(...compareImgs);
            debugImgs.push(...itemDetectionDebugImgs);
        }
        nextProgress();
        const simResults = getSims(compareImgs, itemData.imgMap, itemData.order);
        nextProgress();
        const numImgs = splitNumbers({ splittedImgs, itemWidth, simResults, IMG_SL });
        nextProgress();
        const numResults = await recognizeNumbers(numImgs);
        return {
            data: merge(positions, simResults.map(sim => ({ sim })), numResults.map(num => ({ num }))),
            debug: await Promise.all(debugImgs.map(jimp2base64)),
        };
    }
}
