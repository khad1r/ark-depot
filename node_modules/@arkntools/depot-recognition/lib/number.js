import { last, map, remove, sum } from 'lodash';
import OCRAD from '@arkntools/scripts/dist/ocrad';
import Jimp from 'jimp';
import { jimp2base64 } from '../utils/jimpUtils';
import ImageData from '../utils/ImageData';
import { getRanges, removeRangesNoise } from './range';
const NUM_RESIZE_H = 60;
const NUM_MIN_WIDTH = 8;
const NUM_MAX_SPACE = 20;
const NUM_IMG_PADDING = 10;
const NUM_APPEND_SPACE = 8;
const NUM_CROP_W = 50;
const NUM_CROP_H = 22;
const NUM_CROP_X = 40;
const NUM_CROP_Y = 73;
const NUM_CONVOLUTION_CORE = ((size) => (line => new Array(size).fill(line))(new Array(size).fill(1 / (size * size))))(3);
const getBlackColRanges = (img, fn) => {
    const w = img.getWidth();
    const blackArr = [];
    for (let x = 0; x < w; x++) {
        blackArr.push(fn(img, x));
    }
    return getRanges(blackArr);
};
const isColHasBlack = (img, x) => {
    const h = img.getHeight();
    for (let y = 0; y < h; y++) {
        const { r } = Jimp.intToRGBA(img.getPixelColor(x, y));
        if (r < 128)
            return true;
    }
    return false;
};
export const splitNumbers = ({ splittedImgs, itemWidth, simResults, IMG_SL, }) => {
    const numRatio = itemWidth / IMG_SL;
    const numX = Math.round(NUM_CROP_X * numRatio);
    const numY = Math.round(NUM_CROP_Y * numRatio);
    const numW = Math.round(NUM_CROP_W * numRatio);
    const numH = Math.round(NUM_CROP_H * numRatio);
    return splittedImgs.map((splittedImg, i) => {
        var _a;
        if (!simResults[i])
            return null;
        const numImg = splittedImg
            .clone()
            .crop(numX, numY, numW, numH)
            .resize(Jimp.AUTO, NUM_RESIZE_H, Jimp.RESIZE_BEZIER)
            .invert()
            .threshold({ max: 104 });
        const numImgH = numImg.getHeight();
        const numImgBlackRanges = getBlackColRanges(numImg, isColHasBlack);
        removeRangesNoise(numImgBlackRanges, NUM_MIN_WIDTH);
        if (((_a = numImgBlackRanges[0]) === null || _a === void 0 ? void 0 : _a.start) === 0)
            numImgBlackRanges.splice(0, 1);
        remove(numImgBlackRanges, ({ start, length }, j) => {
            const next = numImgBlackRanges[j + 1];
            if (next && next.start - (start + length) > NUM_MAX_SPACE)
                return true;
            const yBlack = new Array(numImgH).fill(0);
            numImg.scan(start, 0, length, numImgH, function (x, y, idx) {
                yBlack[y] += 255 - this.bitmap.data[idx];
            });
            const yRanges = getRanges(yBlack.map(v => v > 0));
            if (yBlack[0] || last(yBlack))
                return true;
            if (sum(map(yRanges, 'length')) < numImgH * 0.5)
                return true;
            return false;
        });
        if (!numImgBlackRanges.length) {
            numImgBlackRanges.push({ start: 0, length: numImg.getWidth() });
        }
        const newNumImg = new Jimp(NUM_IMG_PADDING * 2 +
            sum(map(numImgBlackRanges, 'length')) +
            (numImgBlackRanges.length - 1) * NUM_APPEND_SPACE, numImgH, 'white');
        let curX = NUM_IMG_PADDING;
        for (const { start, length } of numImgBlackRanges) {
            if (curX !== NUM_IMG_PADDING)
                curX += NUM_APPEND_SPACE;
            newNumImg.blit(numImg, curX, 0, start, 0, length, numImgH);
            curX += length;
        }
        newNumImg
            .convolution(NUM_CONVOLUTION_CORE)
            .invert()
            .threshold({ max: 16, autoGreyscale: false })
            .invert();
        return newNumImg;
    });
};
export const recognizeNumbers = (numImgs) => Promise.all(numImgs.map(async (img) => {
    if (!img)
        return null;
    const imgData = new ImageData(new Uint8ClampedArray(img.bitmap.data), img.bitmap.width, img.bitmap.height);
    const text = OCRAD(imgData, { numeric: true }).trim();
    const value = parseInt(text.replace(/[^0-9]/g, '')) || 1;
    return {
        img: await jimp2base64(img),
        text,
        value,
        warn: text.replace(/ /g, '') !== String(value),
    };
}));
